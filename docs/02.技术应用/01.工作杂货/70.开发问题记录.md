---
title: 开发问题记录
date: 2022-05-11 15:57:03
permalink: /pages/8fe4ca/
categories:
  - 技术应用
  - 工作杂货
tags:
  - 
author: 
  name: luoxiaofeng
  link: https://github.com/954118124
---
## 1 Es数据与Mysql数据不一致
**原因：**
批量操作高峰期，频繁更新数据库导致同步堆积，数据未能及时同步到Es。

**解决方案：**
批量任务控制并发数，控制更新速率。

## 2 内部feign自调用
**描述：**
订单运单解藕，外部接口调用临时改内部feign调用自己，服务重启后出现大量错误。

**原因：**
节点启动有先后顺序，先启动的节点feign调用自己服务时调用的是旧节点，导致调用不到新接口。

**解决方案：**
避免使用feign调用自己服务这种临时方案。

## 3 服务切oracle后出现内存溢出情况
**原因：**
按多个运单号查询列表，先查一个月内将命中数据放到内存，查不到的去掉时间范围再查，最后合并内存中的数据及后面查的数据高峰期接口调用量大导致内存迅速被占满。

**解决方案：**
按运单号查询数据库，由于运单号是全局唯一索引，查询速度足够快，不需要先查一个月再扩大到全部。
<br>
直接按运单号查询即可，这样就不需要将运单数据放在缓存中。

## 4 服务偶发性所有接口变慢
**原因：**
数据库连接数配置未生效，默认只有8，导致业务高峰期获取不到连接数影响接口响应。
<br>
代码里面获取的配置路径是spring.datasource.maxActive，配置文件里面配的是sping.datasource.druid.maxActive。

**解决方案：**
数据库配置调整正确，例：
````yaml
spring:
  datasource:
    druid:
      initialSize: 20
      minIdle: 20
      maxActive: 100
      maxWait: 60000
````

## 5 MQ消息发送阻塞影响相关接口调用变慢
**原因：**
MQ消息消费缓慢，致使队列内存达到30多G触发流控。

**解决方案：**
<br>
1.删除多余、无效的消息发送
<br>
2.优化下游账单消费速度
<br>
3.优化消息体大小，去除不必要字段（后续）
<br>
4.调整为惰性队列（后续）

## 6 服务消费MQ消息自动ACK改手动ACK出现消息堆积
**原因：**
MQ消费端指定了headers，导致不是该headers的消息一直未ack。

**解决方案：**
非指定headers的消息手动确认.
````text
Object o = payload.getHeaders().get(WAYBILL_MQ_HEADER);
if (!String.valueOf(o).equals(WAYBILL_MQ_HEADER_VALUE)) {
  channel.basicAck(deliveryTag, false); // 手动确认
  return;
}
````

## 7 young gc 业务量大时耗时持续飙高
**原因：**
猜测跨年代对象引用

**解决方案：**
<br>
JVM调优 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=2M
<br>
调优原因：经分析每个线程从MQ拉取的对象信息为0.23M，MQ最大线程数为10，默认为0，
<br>
当业务量飙升时，线程扩容到10个，那么将这部分的大对象直接放入老年代，减轻年轻代压力。

## 8 查询接口超时
**原因：**
使用了多表关联查询，其中还有一张大表，导致了查询速度缓慢。单条达到了40-80ms,当批量任务200条数据的请求过来，每次都需要处理将近8-16S。

**解决方案：**
拆sql语句。将多表的关联查询，拆成单表查询，并保证每个查询语句都落到索引，提高每张表的查询效率。优化后200条的批量在1s内可执行完成。

## 9 动态列导出列顺序错乱
**原因：**
在动态列导出时，每次都会去修改VO类的导出字段顺序，在并发导出时，新请求动态列顺序会覆盖上一次动态列顺序，导致生成的文档顺序错乱。
<br>
覆盖原因是在类加载时会将类元信息存入元空间，每次修改都会更新元空间中的类信息，而不管有几个线程，在同一个JVM中，指向的类元信息都是同一个，所以在修改类元信息时，会互相影响。
**解决方案：**
````text
synchronized (voClass) {
    List<String> columnSet = new ArrayList<>();
    columnSet = customColumns.stream().map(item -> item.getName()).collect(Collectors.toList());
    //构建动态导出header
    Class<V> headerClass = this.getCustomerHeaderClass(t, voClass, columnSet);
    excelWriter.write(resultList, writeSheet);
}
````
在导出动态列执行write之前，加锁重新设置导出的列顺序，保证每次的列顺序都是当前线程所需要的，防止互相覆盖。

