(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{530:function(a,t,s){"use strict";s.r(t);var r=s(18),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-什么是事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是事务"}},[a._v("#")]),a._v(" 1 什么是事务？")]),a._v(" "),s("p",[a._v("事务逻辑上的一组操作，组成这组操作的各个逻辑单元,要么一起成功,要么一起失败。")]),a._v(" "),s("h2",{attrs:{id:"_2-事务有哪些特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务有哪些特性"}},[a._v("#")]),a._v(" 2 事务有哪些特性？")]),a._v(" "),s("p",[s("strong",[a._v("事务的特性（ACID）")])]),a._v(" "),s("p",[s("strong",[a._v("原子性（atomicity）:")]),a._v(" 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用;")]),a._v(" "),s("p",[s("strong",[a._v("一致性（consistency）:")]),a._v(" 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的;")]),a._v(" "),s("p",[s("strong",[a._v("隔离性（isolation）:")]),a._v(" 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的;")]),a._v(" "),s("p",[s("strong",[a._v("持久性（durability）:")]),a._v(" 事务一旦结束，数据就持久到数据库。")]),a._v(" "),s("h2",{attrs:{id:"_3-innodb怎么实现事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-innodb怎么实现事务"}},[a._v("#")]),a._v(" 3 innodb怎么实现事务")]),a._v(" "),s("p",[a._v("ACD三个特性是通过Redo log（重做日志）和Undo log实现的。 而隔离性是通过锁来实现的。")]),a._v(" "),s("h2",{attrs:{id:"_4-并发事务带来的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-并发事务带来的问题"}},[a._v("#")]),a._v(" 4 并发事务带来的问题")]),a._v(" "),s("h3",{attrs:{id:"_4-1-脏读-dirty-read"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-脏读-dirty-read"}},[a._v("#")]),a._v(" 4.1 脏读（Dirty read）")]),a._v(" "),s("p",[a._v("脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。")]),a._v(" "),s("h3",{attrs:{id:"_4-2-不可重复读-nonrepeatable-read"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-不可重复读-nonrepeatable-read"}},[a._v("#")]),a._v(" 4.2 不可重复读（Nonrepeatable read）")]),a._v(" "),s("p",[a._v("不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。")]),a._v(" "),s("h3",{attrs:{id:"_4-3-幻影读-phantom-reads"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-幻影读-phantom-reads"}},[a._v("#")]),a._v(" 4.3 幻影读（Phantom reads）")]),a._v(" "),s("p",[a._v("幻影读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。")]),a._v(" "),s("h3",{attrs:{id:"_4-4-不可重复度和幻读区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-不可重复度和幻读区别"}},[a._v("#")]),a._v(" 4.4 不可重复度和幻读区别")]),a._v(" "),s("p",[a._v("不可重复读的重点是修改，幻读的重点在于新增或者删除。")]),a._v(" "),s("h2",{attrs:{id:"_5-事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-事务隔离级别"}},[a._v("#")]),a._v(" 5 事务隔离级别")]),a._v(" "),s("h3",{attrs:{id:"_5-1-read-uncommitted-读取未提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-read-uncommitted-读取未提交"}},[a._v("#")]),a._v(" 5.1 READ-UNCOMMITTED(读取未提交)")]),a._v(" "),s("p",[a._v("最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读")]),a._v(" "),s("h3",{attrs:{id:"_5-2-read-committed-读取已提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-read-committed-读取已提交"}},[a._v("#")]),a._v(" 5.2 READ-COMMITTED(读取已提交)")]),a._v(" "),s("p",[a._v("允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),a._v(" "),s("h3",{attrs:{id:"_5-3-repeatable-read-可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-repeatable-read-可重复读"}},[a._v("#")]),a._v(" 5.3 REPEATABLE-READ(可重复读)")]),a._v(" "),s("p",[a._v("对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),a._v(" "),s("h3",{attrs:{id:"_5-4-serializable-串行化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-serializable-串行化"}},[a._v("#")]),a._v(" 5.4 SERIALIZABLE(串行化)")]),a._v(" "),s("p",[a._v("最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。")]),a._v(" "),s("h3",{attrs:{id:"_5-5-数据库默认隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-数据库默认隔离级别"}},[a._v("#")]),a._v(" 5.5 数据库默认隔离级别")]),a._v(" "),s("p",[a._v("MySQL InnoDB 存储引擎的默认支持的隔离级别是：REPEATABLE-READ（可重读）")]),a._v(" "),s("p",[a._v("Oracle 默认：READ-COMMITTED（读已提交）")]),a._v(" "),s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/a94967fbc3b08e972fee8687d3a96146.png",width:"70%"}}),a._v(" "),s("h2",{attrs:{id:"_6-spring-事务中的隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring-事务中的隔离级别"}},[a._v("#")]),a._v(" 6 Spring 事务中的隔离级别")]),a._v(" "),s("p",[s("strong",[a._v("TransactionDefinition 接口中定义了五个表示隔离级别的常量:")])]),a._v(" "),s("p",[a._v("TransactionDefinition.ISOLATION_DEFAULT")]),a._v(" "),s("p",[a._v("TransactionDefinition.ISOLATION_READ_UNCOMMITTED")]),a._v(" "),s("p",[a._v("TransactionDefinition.ISOLATION_READ_COMMITTED")]),a._v(" "),s("p",[a._v("TransactionDefinition.ISOLATION_REPEATABLE_READ")]),a._v(" "),s("p",[a._v("TransactionDefinition.ISOLATION_SERIALIZABLE")]),a._v(" "),s("h3",{attrs:{id:"_6-1-isolation-default"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-isolation-default"}},[a._v("#")]),a._v(" 6.1 ISOLATION_DEFAULT")]),a._v(" "),s("p",[a._v("使用后端数据库默认的隔离级别。")]),a._v(" "),s("p",[a._v("Mysql 默认采用的 REPEATABLE_READ隔离级别。Oracle 默认采用的 READ_COMMITTED隔离级别。")]),a._v(" "),s("h3",{attrs:{id:"_6-2-isolation-read-uncommitted"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-isolation-read-uncommitted"}},[a._v("#")]),a._v(" 6.2 ISOLATION_READ_UNCOMMITTED")]),a._v(" "),s("p",[a._v("最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。")]),a._v(" "),s("h3",{attrs:{id:"_6-3-isolation-read-committed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-isolation-read-committed"}},[a._v("#")]),a._v(" 6.3 ISOLATION_READ_COMMITTED")]),a._v(" "),s("p",[a._v("允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。")]),a._v(" "),s("h3",{attrs:{id:"_6-4-isolation-repeatable-read"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-isolation-repeatable-read"}},[a._v("#")]),a._v(" 6.4 ISOLATION_REPEATABLE_READ")]),a._v(" "),s("p",[a._v("对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),a._v(" "),s("h3",{attrs:{id:"_6-5-isolation-serializable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-isolation-serializable"}},[a._v("#")]),a._v(" 6.5 ISOLATION_SERIALIZABLE")]),a._v(" "),s("p",[a._v("最高的隔离级别，完全服从ACID的隔离级别。")]),a._v(" "),s("p",[a._v("所有事务依次逐个执行，事务之间不产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。")]),a._v(" "),s("p",[a._v("但是这将严重影响程序的性能。通常情况下也不会用到该级别。")]),a._v(" "),s("h2",{attrs:{id:"_7-spring事务的7种传播行为"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring事务的7种传播行为"}},[a._v("#")]),a._v(" 7 Spring事务的7种传播行为")]),a._v(" "),s("h3",{attrs:{id:"_7-1-保证同一个事务中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-保证同一个事务中"}},[a._v("#")]),a._v(" 7.1 保证同一个事务中")]),a._v(" "),s("h4",{attrs:{id:"_1-propagation-required"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-propagation-required"}},[a._v("#")]),a._v(" 1 PROPAGATION_REQUIRED")]),a._v(" "),s("p",[s("strong",[a._v("如果存在一个事务则支持当前事务，如果不存在就新建一个(默认)")])]),a._v(" "),s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/5ebd355004cffff75d16dcbbad70ff50.png",width:"70%"}}),a._v(" "),s("h4",{attrs:{id:"_2-propagation-supports"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-propagation-supports"}},[a._v("#")]),a._v(" 2 PROPAGATION_SUPPORTS")]),a._v(" "),s("p",[s("strong",[a._v("如果存在一个事务则支持当前事务，如果不存在，就不使用事务")])]),a._v(" "),s("p",[s("strong",[s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/8739e831fd7c045572d57af1727a58a9.png",width:"70%"}})])]),a._v(" "),s("h4",{attrs:{id:"_3-propagation-mandatory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-propagation-mandatory"}},[a._v("#")]),a._v(" 3 PROPAGATION_MANDATORY")]),a._v(" "),s("p",[s("strong",[a._v("如果存在一个事务则支持当前事务，如果不存在，抛出异常")])]),a._v(" "),s("p",[s("strong",[s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/e8b9cf464c845d1e6789e1d9fa7990f8.png",width:"70%"}})])]),a._v(" "),s("h3",{attrs:{id:"_7-1-保证没有在同一个事务中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-保证没有在同一个事务中"}},[a._v("#")]),a._v(" 7.1 保证没有在同一个事务中")]),a._v(" "),s("h4",{attrs:{id:"propagation-requires-new"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#propagation-requires-new"}},[a._v("#")]),a._v(" PROPAGATION_REQUIRES_NEW")]),a._v(" "),s("p",[s("strong",[a._v("如果有事务存在，挂起当前事务，创建一个新的事务")])]),a._v(" "),s("p",[s("strong",[s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/62b28f87dbe5152367d921c6389a53c9.png",width:"70%"}})])]),a._v(" "),s("h4",{attrs:{id:"_5-propagation-not-supported"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-propagation-not-supported"}},[a._v("#")]),a._v(" 5.PROPAGATION_NOT_SUPPORTED")]),a._v(" "),s("p",[s("strong",[a._v("以非事务方式运行，如果有事务存在，挂起当前事务")])]),a._v(" "),s("p",[s("strong",[s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/0eb5d553d14fb2587cb1d76b6d5f99a9.png",width:"70%"}})])]),a._v(" "),s("h4",{attrs:{id:"_6-propagation-never"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-propagation-never"}},[a._v("#")]),a._v(" 6.PROPAGATION_NEVER")]),a._v(" "),s("p",[s("strong",[a._v("以非事务方式运行，如果有事务存在，抛出异常")])]),a._v(" "),s("h4",{attrs:{id:"_7-propagation-nested"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-propagation-nested"}},[a._v("#")]),a._v(" 7.PROPAGATION_NESTED")]),a._v(" "),s("p",[s("strong",[a._v("如果当前事务存在，则嵌套事务执行")])]),a._v(" "),s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/5beb9270fd8429f96118093e23a9f289.png",width:"70%"}}),a._v(" "),s("h3",{attrs:{id:"_7-2-传播级别不生效原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-传播级别不生效原因"}},[a._v("#")]),a._v(" 7.2 传播级别不生效原因？")]),a._v(" "),s("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/5825e61f42435a62cbc1282493e92da0.png",width:"70%"}}),a._v(" "),s("p",[a._v("必须用注入的实例（代理类实例，有代理事务逻辑处理），否则只是普通类实例会导致事务代码不生效。")]),a._v(" "),s("p",[a._v("可以类自己注入自己实例。")])])}),[],!1,null,null,null);t.default=_.exports}}]);