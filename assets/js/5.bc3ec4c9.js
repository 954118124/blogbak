(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{494:function(t,a,s){"use strict";s.r(a);var r=s(30),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"面向对象设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计原则"}},[t._v("#")]),t._v(" 面向对象设计原则")]),t._v(" "),s("h3",{attrs:{id:"开闭原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),s("p",[t._v("对扩展开放，对修改关闭。\n极端要求就是：程序完成后，除非是修改错误，不然不能修改代码，只能扩展代码。")]),t._v(" "),s("h3",{attrs:{id:"依赖导致原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖导致原则"}},[t._v("#")]),t._v(" 依赖导致原则")]),t._v(" "),s("p",[t._v("调用者（客户代码）不依赖于被调用者（实现代码）的实现细节，而是依赖其抽象\n调用者不依赖被调用者的具体实现，而是依赖被调用者的抽象，这样被调用者后续可以被无感替换掉。")]),t._v(" "),s("h3",{attrs:{id:"单一职责原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),s("p",[t._v("一个类，最好只做一件事，只有一个引起它的变化。")]),t._v(" "),s("h3",{attrs:{id:"接口隔离原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),s("p",[t._v("使用多个小的专门的接口，而不要使用一个大的总接口。")]),t._v(" "),s("h3",{attrs:{id:"最少知道原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最少知道原则"}},[t._v("#")]),t._v(" 最少知道原则")]),t._v(" "),s("p",[t._v("一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。")]),t._v(" "),s("h3",{attrs:{id:"合成复用原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则"}},[t._v("#")]),t._v(" 合成复用原则")]),t._v(" "),s("p",[t._v("原则是尽量使用合成/聚合的方式，而不是使用继承。")]),t._v(" "),s("h3",{attrs:{id:"里氏替换原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[t._v("#")]),t._v(" 里氏替换原则")]),t._v(" "),s("p",[t._v("子类必须能够替换其基类。\n类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。")])])}),[],!1,null,null,null);a.default=e.exports}}]);