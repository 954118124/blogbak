(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{504:function(a,h,s){"use strict";s.r(h);var t=s(18),_=Object(t.a)({},(function(){var a=this,h=a.$createElement,s=a._self._c||h;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-数组和链表区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组和链表区别"}},[a._v("#")]),a._v(" 1 数组和链表区别？")]),a._v(" "),s("p",[a._v("1.链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。")]),a._v(" "),s("p",[a._v("链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难。")]),a._v(" "),s("p",[a._v("3.数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。")]),a._v(" "),s("h2",{attrs:{id:"_2-hashmap的数据结构-默认初试容量和负载因子是多少"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-hashmap的数据结构-默认初试容量和负载因子是多少"}},[a._v("#")]),a._v(" 2 HashMap的数据结构？默认初试容量和负载因子是多少？")]),a._v(" "),s("p",[a._v("1.数组+链表，链表长度大于8时接红黑树。")]),a._v(" "),s("p",[a._v("初始容量（16）和负载因子（0.75）（负载因子就是指填充到多少开始扩大容量）。")]),a._v(" "),s("h2",{attrs:{id:"_3-hashmap的数组长度为什么要保证是2的幂"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-hashmap的数组长度为什么要保证是2的幂"}},[a._v("#")]),a._v(" 3 hashmap的数组长度为什么要保证是2的幂？")]),a._v(" "),s("p",[a._v("在HashMap中通过利用key的hashcode值,来进行位运算")]),a._v(" "),s("p",[a._v("公式:index = e.hash & (newCap - 1)")]),a._v(" "),s("p",[a._v("length - 1的值是所有二进制位全为1,这种情况下,index的结果等同于hashcode后几位的值")]),a._v(" "),s("p",[a._v("只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的。")]),a._v(" "),s("p",[a._v("所以,HashMap的默认长度为16,是为了降低hash碰撞的几率。")]),a._v(" "),s("h2",{attrs:{id:"_4-hashmap的扩容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-hashmap的扩容"}},[a._v("#")]),a._v(" 4 hashmap的扩容？")]),a._v(" "),s("p",[a._v("rehash：当Map中的元素大于数组长度的75%时，就会进行扩容，JDK1.7之前扩容时很有可能会造成环链，后续get时则可能会变成死循环，线程不安全。")]),a._v(" "),s("img",{staticClass:"imgcss",attrs:{src:"/img/media/81633c5cec010d92fc2717c41a6f5391.png",width:"70%"}}),a._v(" "),s("h2",{attrs:{id:"_5-concurrenthashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-concurrenthashmap"}},[a._v("#")]),a._v(" 5 ConcurrentHashMap")]),a._v(" "),s("p",[a._v("JDK1.7中ConcurrentHashMap采用分段锁，分成16个小的hashMap，锁定当前的小hashMap其他")]),a._v(" "),s("p",[a._v("hashMap不受影响。JDK1.8之后不再采取分段锁，主要采用CAS原子指令实现无锁的高并发操作。")]),a._v(" "),s("h2",{attrs:{id:"_6-concurrenthashmap-1-7-与-1-8-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-concurrenthashmap-1-7-与-1-8-区别"}},[a._v("#")]),a._v(" 6 ConcurrentHashMap 1.7 与 1.8 区别?")]),a._v(" "),s("p",[a._v("1.JDK1.8 采用 synchronized 代替可重入锁 ReentrantLock。")]),a._v(" "),s("p",[a._v("2.JDK1.8 取消了 Segment 分段锁的数据结构，使用数组+链表+红黑树的结构代替。")]),a._v(" "),s("p",[a._v("3.JDK1.8 对每个数组元素加锁，1.7 对要操作的 Segment 数据段加锁。")])])}),[],!1,null,null,null);h.default=_.exports}}]);