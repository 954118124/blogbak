(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{518:function(a,t,r){"use strict";r.r(t);var e=r(18),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"redis怎么进行过期删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis怎么进行过期删除"}},[a._v("#")]),a._v(" redis怎么进行过期删除？")]),a._v(" "),r("p",[a._v("我们set key的时候，都可以给一个expire time，就是过期时间，通过过期时间可以指定这个key存活的时间。")]),a._v(" "),r("p",[a._v("如果假设你设置了一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的?")]),a._v(" "),r("p",[r("strong",[a._v("定期删除+惰性删除。")])]),a._v(" "),r("h2",{attrs:{id:"_1-定期删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-定期删除"}},[a._v("#")]),a._v(" 1 定期删除")]),a._v(" "),r("p",[a._v("redis默认是每隔 "),r("strong",[a._v("100ms")]),a._v(" 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢?你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载!")]),a._v(" "),r("h2",{attrs:{id:"_2-惰性删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-惰性删除"}},[a._v("#")]),a._v(" 2 惰性删除")]),a._v(" "),r("p",[a._v("定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈!")]),a._v(" "),r("p",[a._v("但是仅仅通过设置过期时间还是有问题的。我们想一下:如果定期删除漏掉了很多过期 key，然后你也没及时去查， 也就没走惰性删除，此时会怎么样?如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢? -- "),r("strong",[a._v("redis内存淘汰机制。")])]),a._v(" "),r("h2",{attrs:{id:"_3-主动清理策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-主动清理策略"}},[a._v("#")]),a._v(" 3 主动清理策略")]),a._v(" "),r("p",[r("strong",[a._v("根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，")])]),a._v(" "),r("p",[r("strong",[a._v("推荐使用volatile-lru。")])]),a._v(" "),r("p",[a._v("主动清理策略在Redis4.0之前一共实现了6种"),r("strong",[a._v("内存淘汰策略")]),a._v("，在4.0之后，又增加了2种策略，总共8种策略：")]),a._v(" "),r("h3",{attrs:{id:"a-设置过期时间的key做处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-设置过期时间的key做处理"}},[a._v("#")]),a._v(" a) 设置过期时间的key做处理")]),a._v(" "),r("h4",{attrs:{id:"_3-1-volatile-ttl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-volatile-ttl"}},[a._v("#")]),a._v(" 3.1 volatile-ttl")]),a._v(" "),r("p",[a._v("在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。")]),a._v(" "),r("h4",{attrs:{id:"_3-2-volatile-random"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-volatile-random"}},[a._v("#")]),a._v(" 3.2 volatile-random")]),a._v(" "),r("p",[a._v("就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。")]),a._v(" "),r("h4",{attrs:{id:"_3-3-volatile-lru"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-volatile-lru"}},[a._v("#")]),a._v(" 3.3 volatile-lru")]),a._v(" "),r("p",[a._v("会使用 LRU 算法筛选设置了过期时间的键值对删除。")]),a._v(" "),r("h4",{attrs:{id:"_3-4-volatile-lfu"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-volatile-lfu"}},[a._v("#")]),a._v(" 3.4 volatile-lfu")]),a._v(" "),r("p",[a._v("会使用 LFU 算法筛选设置了过期时间的键值对删除。")]),a._v(" "),r("h3",{attrs:{id:"b-针对所有的key做处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-针对所有的key做处理"}},[a._v("#")]),a._v(" b) 针对所有的key做处理")]),a._v(" "),r("h4",{attrs:{id:"_3-5-allkeys-random"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-allkeys-random"}},[a._v("#")]),a._v(" 3.5 allkeys-random")]),a._v(" "),r("p",[a._v("从所有键值对中随机选择并删除数据。")]),a._v(" "),r("h4",{attrs:{id:"_3-6-allkeys-lru"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-allkeys-lru"}},[a._v("#")]),a._v(" 3.6 allkeys-lru")]),a._v(" "),r("p",[a._v("使用 LRU 算法在所有数据中进行筛选删除。")]),a._v(" "),r("h4",{attrs:{id:"_3-7-allkeys-lfu"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-allkeys-lfu"}},[a._v("#")]),a._v(" 3.7 allkeys-lfu")]),a._v(" "),r("p",[a._v("使用 LFU 算法在所有数据中进行筛选删除。")]),a._v(" "),r("h3",{attrs:{id:"c-不处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-不处理"}},[a._v("#")]),a._v(" c) 不处理")]),a._v(" "),r("h4",{attrs:{id:"_3-8-noeviction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-noeviction"}},[a._v("#")]),a._v(" 3.8 noeviction")]),a._v(" "),r("p",[a._v('不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作。')]),a._v(" "),r("h2",{attrs:{id:"_4-lfu、lru数据淘汰策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-lfu、lru数据淘汰策略"}},[a._v("#")]),a._v(" 4 LFU、LRU数据淘汰策略")]),a._v(" "),r("h3",{attrs:{id:"_4-1-lru"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-lru"}},[a._v("#")]),a._v(" 4.1 LRU")]),a._v(" "),r("p",[a._v("LRU 算法(Least Recently Used，最近最少使用)")]),a._v(" "),r("p",[a._v("淘汰很久没被访问过的数据，以"),r("strong",[a._v("最近一次访问时间")]),a._v("作为参考。")]),a._v(" "),r("h3",{attrs:{id:"_4-2-lfu"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-lfu"}},[a._v("#")]),a._v(" 4.2 LFU")]),a._v(" "),r("p",[a._v("LFU 算法(Least Frequently Used，最不经常使用)")]),a._v(" "),r("p",[a._v("淘汰最近一段时间被访问次数最少的数据，以"),r("strong",[a._v("次数")]),a._v("作为参考。")]),a._v(" "),r("h3",{attrs:{id:"_4-3-配置建议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-配置建议"}},[a._v("#")]),a._v(" 4.3 配置建议")]),a._v(" "),r("p",[a._v("当存在热点数据时，"),r("strong",[a._v("LRU")]),a._v("的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用"),r("strong",[a._v("LFU")]),a._v("可能更好点。")])])}),[],!1,null,null,null);t.default=s.exports}}]);