(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{520:function(a,s,_){"use strict";_.r(s);var t=_(18),v=Object(t.a)({},(function(){var a=this,s=a.$createElement,_=a._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("p",[_("strong",[a._v("Redis的持久化方式：快照(snapshotting，RDB)，只追加文件(append-only file,AOF)。")])]),a._v(" "),_("h2",{attrs:{id:"_1-rdb持久化-快照持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-rdb持久化-快照持久化"}},[a._v("#")]),a._v(" 1 RDB持久化(快照持久化)")]),a._v(" "),_("p",[a._v("RDB持久化是将内存中的数据以快照的方式写进二进制文件中，默认的文件名为：dump.rdb。")]),a._v(" "),_("p",[_("strong",[a._v("快照持久化是Redis默认采用的持久化方式")]),a._v("。")]),a._v(" "),_("h3",{attrs:{id:"_1-1-rdb持久化是怎么触发的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-rdb持久化是怎么触发的"}},[a._v("#")]),a._v(" 1.1 RDB持久化是怎么触发的？")]),a._v(" "),_("p",[_("strong",[a._v("RDB支持3种触发方式：save，bgsave，自动化。")])]),a._v(" "),_("h4",{attrs:{id:"_1-1-1-save触发方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-save触发方式"}},[a._v("#")]),a._v(" 1.1.1 save触发方式")]),a._v(" "),_("p",[a._v("该命令会阻塞redis服务器，命令执行期间redis不能执行其他命令，直到RDB过程结束。")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/e03ed58801da1a3a0ad379dc409ff54d.png",width:"70%"}}),a._v(" "),_("h4",{attrs:{id:"_1-1-2-bgsave触发方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-bgsave触发方式"}},[a._v("#")]),a._v(" 1.1.2 bgsave触发方式")]),a._v(" "),_("p",[a._v("该命令不会阻塞redis服务器，命令执行期间redis还可以响应客户端需求。")]),a._v(" "),_("p",[a._v("具体过程是redis进程执行fork操作创建一个子进程，RDB持久化过程由该子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短**。Redis内部所有RDB操作基本上都是用bgsave命令。**")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/88b798b1dd4b5e79f82821b8aaf5bb47.png",width:"70%"}}),a._v(" "),_("h4",{attrs:{id:"_1-1-3-自动触发方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-自动触发方式"}},[a._v("#")]),a._v(" 1.1.3 自动触发方式")]),a._v(" "),_("p",[a._v("自动触发是由我们配置文件来完成的。在redis.conf配置文件中默认有此下配置:")]),a._v(" "),_("p",[a._v("save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发"),_("strong",[a._v("bgsave")]),a._v("命令创建快照。")]),a._v(" "),_("p",[a._v("save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发"),_("strong",[a._v("bgsave")]),a._v("命令创建快照。")]),a._v(" "),_("p",[a._v("save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发"),_("strong",[a._v("bgsave")]),a._v("命令创建快照。")]),a._v(" "),_("h3",{attrs:{id:"_1-2-rdb有什么优势和劣势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-rdb有什么优势和劣势"}},[a._v("#")]),a._v(" 1.2 RDB有什么优势和劣势？")]),a._v(" "),_("h4",{attrs:{id:"_1-2-1-rdb优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-rdb优势"}},[a._v("#")]),a._v(" 1.2.1 RDB优势")]),a._v(" "),_("p",[a._v("1）RDB文件紧凑，全量备份，非常适合数据备份和灾难恢复。")]),a._v(" "),_("p",[a._v("2）RDB过程可通过子线程进行，不影响redis主线程。")]),a._v(" "),_("p",[a._v("3）恢复大数据集时，恢复速度比AOF恢复速度快。")]),a._v(" "),_("h4",{attrs:{id:"_1-2-1-rdb劣势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-rdb劣势"}},[a._v("#")]),a._v(" 1.2.1 RDB劣势")]),a._v(" "),_("p",[a._v("快照持久化期间修改的数据不会被保存，可能丢失数据。")]),a._v(" "),_("h2",{attrs:{id:"_2-aof持久化-append-only-file"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-aof持久化-append-only-file"}},[a._v("#")]),a._v(" 2 AOF持久化(append-only file)")]),a._v(" "),_("p",[a._v("AOF的工作机制很简单，就是redis把每一个收到的写命令都追加保存到AOF文件中。")]),a._v(" "),_("p",[a._v("与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。")]),a._v(" "),_("p",[_("strong",[a._v("默认情况下Redis没有开启")]),a._v("。")]),a._v(" "),_("p",[a._v("AOF(append only file)方式的持久化，可以通过appendonly参数开启: "),_("strong",[a._v("appendonly yes")])]),a._v(" "),_("h3",{attrs:{id:"_2-1-aof的持久化是怎么触发的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-aof的持久化是怎么触发的"}},[a._v("#")]),a._v(" 2.1 AOF的持久化是怎么触发的？")]),a._v(" "),_("p",[a._v("在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是:")]),a._v(" "),_("h4",{attrs:{id:"_2-1-1-appendfsync-always"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-appendfsync-always"}},[a._v("#")]),a._v(" 2.1.1 appendfsync always")]),a._v(" "),_("p",[a._v("每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度。")]),a._v(" "),_("h4",{attrs:{id:"_2-1-2-appendfsync-everysec"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-appendfsync-everysec"}},[a._v("#")]),a._v(" 2.1.2 appendfsync everysec")]),a._v(" "),_("p",[a._v("异步操作，每秒钟同步一次数据到硬盘，如果1秒内宕机，有数据丢失。")]),a._v(" "),_("h4",{attrs:{id:"_2-1-3-appendfsync-no"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-appendfsync-no"}},[a._v("#")]),a._v(" 2.1.3 appendfsync no")]),a._v(" "),_("p",[a._v("让操作系统决定何时进行同步。")]),a._v(" "),_("h3",{attrs:{id:"_2-2-aof持久化3种触发方式的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-aof持久化3种触发方式的对比"}},[a._v("#")]),a._v(" 2.2 AOF持久化3种触发方式的对比？")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/38f940b5119a6cc859b2e2d75c4284f2.png",width:"70%"}}),a._v(" "),_("h3",{attrs:{id:"_2-3-aof方式什么时候会出现文件重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-aof方式什么时候会出现文件重写"}},[a._v("#")]),a._v(" 2.3 AOF方式什么时候会出现文件重写？")]),a._v(" "),_("p",[a._v("由于AOF方式会记录所有的写命令，对于同一份数据来说，AOF日志文件要比RDB快照文件更大。随着持久化文件越来越大，redis会fork出子线程来将文件进行重写。")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/7f33fa214ed8a710cc19617c6ff64ec9.png",width:"70%"}}),a._v(" "),_("p",[_("strong",[a._v("重写AOF文件不会读取旧文件，而是将内存中的数据内容用命令的方式重写一个新的AOF文件。")])]),a._v(" "),_("h3",{attrs:{id:"_2-4-aof有什么优势和劣势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-aof有什么优势和劣势"}},[a._v("#")]),a._v(" 2.4 AOF有什么优势和劣势？")]),a._v(" "),_("h4",{attrs:{id:"_2-4-1-aof优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-aof优势"}},[a._v("#")]),a._v(" 2.4.1 AOF优势")]),a._v(" "),_("p",[a._v("1）AOF可以更好地保护数据不丢失，一般设置每隔1秒同步一次数据，所以最多丢失1秒的数据。")]),a._v(" "),_("p",[a._v("2）AOF日志文件每次写入数据都是追加，写入性能很高。")]),a._v(" "),_("p",[a._v("3）AOF可以后台操作，不影响客户端读写。")]),a._v(" "),_("p",[a._v("4）AOF非常适合针对误删等情况进行数据恢复。比如有人不小心执行了flushall命令清空了数据，可以通过删除AOF文件中最后一条flushall命令，再将AOF文件放回去，执行恢复操作，恢复所有数据。")]),a._v(" "),_("h4",{attrs:{id:"_2-4-2-aof劣势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-2-aof劣势"}},[a._v("#")]),a._v(" 2.4.2 AOF劣势")]),a._v(" "),_("p",[a._v("1）针对同一份数据，AOF日志文件通常比RDB快照文件大。")]),a._v(" "),_("h2",{attrs:{id:"_3-混合持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-混合持久化"}},[a._v("#")]),a._v(" 3 混合持久化")]),a._v(" "),_("p",[_("strong",[a._v("RDB和AOF的特点：")])]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/944b104913f11a8b192a02246e206701.png",width:"70%"}}),a._v(" "),_("p",[a._v("Redis 4.0 带来了一个新的持久化选项——混合持久化。")]),a._v(" "),_("p",[a._v("重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。")]),a._v(" "),_("p",[_("strong",[a._v("通过如下配置可以开启混合持久化(必须先开启aof):")])]),a._v(" "),_("p",[a._v("#aof‐use‐rdb‐preambleyes")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/83c1071129c2b10e00b8fd93056964c8.png",width:"40%"}}),a._v(" "),_("p",[a._v("AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且"),_("strong",[a._v("将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件")]),a._v("，重写完新的AOF文件覆盖原有的AOF文件，完成新旧两个AOF文件的替换。")]),a._v(" "),_("h2",{attrs:{id:"_4-数据怎么恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-数据怎么恢复"}},[a._v("#")]),a._v(" 4 数据怎么恢复？")]),a._v(" "),_("p",[_("strong",[a._v("例：")])]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"/img/media/7a2255808964c6f67eb27c19e8808142.png",width:"70%"}})])}),[],!1,null,null,null);s.default=v.exports}}]);