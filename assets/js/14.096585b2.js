(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{508:function(a,t,_){"use strict";_.r(t);var v=_(18),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"_1-内存模型图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存模型图"}},[a._v("#")]),a._v(" 1 内存模型图")]),a._v(" "),_("img",{attrs:{src:"http://media.luoxiaofeng.cn/blog/img/90c03b577608a9ec1503e8b44f6828dd.png"}}),a._v(" "),_("h2",{attrs:{id:"_2-jvm内存参数设置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm内存参数设置"}},[a._v("#")]),a._v(" 2 JVM内存参数设置")]),a._v(" "),_("img",{attrs:{src:"http://media.luoxiaofeng.cn/blog/img/a6b6c0f3eb6b5c9864de998fd7f2678e.png"}}),a._v(" "),_("p",[a._v("-Xss设越小count值越小，说明一个线程栈里能分配的栈帧就越少，但对JVM整体来说能开启的线程数会更多。")]),a._v(" "),_("h2",{attrs:{id:"_3-为什么要将永久代-permgen-替换为元空间-metaspace"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要将永久代-permgen-替换为元空间-metaspace"}},[a._v("#")]),a._v(" 3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）？")]),a._v(" "),_("p",[a._v("1.永久代受限于JVM本身设置的固定大小上限。元空间使用的是直接内存，只受本机可用内存限制。")]),a._v(" "),_("img",{staticClass:"imgcss",attrs:{src:"http://media.luoxiaofeng.cn/blog/img/923dd695a303b0ca78c8d89aa57c1fae.png",width:"70%"}}),a._v(" "),_("h2",{attrs:{id:"_4-jvm内存模型包括哪些数据区域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-jvm内存模型包括哪些数据区域"}},[a._v("#")]),a._v(" 4 JVM内存模型包括哪些数据区域？")]),a._v(" "),_("p",[a._v("主要包括5大块。")]),a._v(" "),_("p",[a._v("1.方法区（元空间），堆都为数据共享区域，有线程安全问题。")]),a._v(" "),_("p",[a._v("2.栈、本地方法栈、程序计数器为独享区域，不存在线程问题。")]),a._v(" "),_("h3",{attrs:{id:"_4-1-方法区-元空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-方法区-元空间"}},[a._v("#")]),a._v(" 4.1 方法区（元空间）")]),a._v(" "),_("p",[a._v("存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码等数据。方法区还有一个别名叫Non-Heap（非堆）。")]),a._v(" "),_("h3",{attrs:{id:"_4-2-堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-堆"}},[a._v("#")]),a._v(" 4.2 堆")]),a._v(" "),_("p",[a._v("此内存区域的唯一目的就是存放对象实例，几乎所有对象实例以及数组都在这里分配内存。")]),a._v(" "),_("p",[a._v("JDK1.7之后开始默认开启逃逸分析：如果某些方法中的对象没有被返回或者未被外面引用（未逃逸），那么该对象可以在栈上分配内存。")]),a._v(" "),_("h3",{attrs:{id:"_4-3-栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-栈"}},[a._v("#")]),a._v(" 4.3 栈")]),a._v(" "),_("p",[a._v("栈也就是Java虚拟机栈，由一个个栈帧组成，每个栈帧拥有：")]),a._v(" "),_("p",[a._v("局部变量表、操作数栈、动态链接、方法出口信息。")]),a._v(" "),_("p",[a._v("局部变量表主要存放编译期可知的各种数据类型（byte、short、int、long、float、double、boolean、char）、对象引用。")]),a._v(" "),_("p",[a._v("每一次方法的调用都会有一个对应的栈帧被压入java栈，方法调用结束后，栈帧弹出。")]),a._v(" "),_("p",[a._v("Java方法有2种返回方式：")]),a._v(" "),_("p",[a._v("1.return语句。")]),a._v(" "),_("p",[a._v("2.抛出异常。")]),a._v(" "),_("p",[a._v("不管哪种返回方式都会导致栈帧弹出。")]),a._v(" "),_("h3",{attrs:{id:"_4-4-本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-本地方法栈"}},[a._v("#")]),a._v(" 4.4 本地方法栈")]),a._v(" "),_("p",[a._v("和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈执行的是Java方法服务，本地方法栈执行的是Native方法服务。")]),a._v(" "),_("p",[a._v("本地方法执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。")]),a._v(" "),_("p",[a._v("本地方法执行完毕后也会出栈并释放内存空间。")]),a._v(" "),_("h3",{attrs:{id:"_4-5-程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-程序计数器"}},[a._v("#")]),a._v(" 4.5 程序计数器")]),a._v(" "),_("p",[a._v("每条线程都有独立的程序计数器，各线程之间计数器互不影响。")])])}),[],!1,null,null,null);t.default=s.exports}}]);