(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{512:function(t,s,a){"use strict";a.r(s);var _=a(18),v=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-jmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-jmap"}},[t._v("#")]),t._v(" 1 jmap")]),t._v(" "),a("p",[t._v("jps")]),t._v(" "),a("p",[t._v("14660 jar")]),t._v(" "),a("p",[t._v("jmap -histo 14660 > ./log.txt")]),t._v(" "),a("p",[t._v("此命令可查看内存信息，实例个数以及占用内存大小")]),t._v(" "),a("img",{staticClass:"imgcss",attrs:{src:"/img/media/ee5cae1992ecc99c25fe99dfeb74e9b7.png",width:"70%"}}),t._v(" "),a("p",[t._v("jmap -heap 14660")]),t._v(" "),a("p",[t._v("查看堆信息")]),t._v(" "),a("img",{staticClass:"imgcss",attrs:{src:"/img/media/aa281fb8c926c6d659fb47b8db3f896b.png",width:"70%"}}),t._v(" "),a("p",[t._v("jmap -dump:format=b,file=test.hprof 14660")]),t._v(" "),a("p",[t._v("也可以设置内存溢出自动导出dump文件（内存很大的时候，可能会导不出来）")]),t._v(" "),a("p",[t._v("1.-XX:+HeapDumpOnOutOfMemoryError")]),t._v(" "),a("p",[t._v("2.-XX:HeapDumpPath=./ （路径）")]),t._v(" "),a("img",{staticClass:"imgcss",attrs:{src:"/img/media/7273cd62e89d1b5ea88fec5aae2e3266.png",width:"70%"}}),t._v(" "),a("h2",{attrs:{id:"_2-jstack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-jstack"}},[t._v("#")]),t._v(" 2 jstack")]),t._v(" "),a("p",[t._v("找出占用cpu最高的线程堆栈信息")]),t._v(" "),a("p",[t._v("top")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/f8ef0d688842a566f723cc57002f2142.png",width:"70%"}})])]),t._v(" "),a("p",[t._v("top -p 24")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/f60d39f68a8f605e4f1c5a9b838b64aa.png",width:"70%"}})])]),t._v(" "),a("p",[t._v("按H，获取每个线程的内存情况")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/f94a3070340bc6b32f3040ec15ae5415.png",width:"70%"}})])]),t._v(" "),a("p",[t._v("1.找到内存和cpu占用最高的线程pid，比如797，转换成16进制得到0x31D")]),t._v(" "),a("p",[t._v("2.执行jstack 24 | grep -A 10 31D")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/a3c38455a85d0c65c0df1d199cc9d6c8.png",width:"70%"}})])]),t._v(" "),a("h2",{attrs:{id:"_3-jinfo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-jinfo"}},[t._v("#")]),t._v(" 3 jinfo")]),t._v(" "),a("p",[t._v("jinfo -flags 24")]),t._v(" "),a("p",[t._v("查看jvm的参数")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/bdb2fcaa138bb5963da172cfcd237d9e.png",width:"70%"}})])]),t._v(" "),a("h2",{attrs:{id:"_4-jstat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-jstat"}},[t._v("#")]),t._v(" 4 jstat")]),t._v(" "),a("p",[t._v("jstat -gc 24")]),t._v(" "),a("p",[t._v("jstat -gc pid 最常用，可以评估程序内存使用及gc压力整体情况")]),t._v(" "),a("p",[a("strong",[a("img",{staticClass:"imgcss",attrs:{src:"/img/media/02f80bcf0ae26cdd134bae7f6e3a21c4.png",width:"70%"}})])]),t._v(" "),a("p",[t._v("可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。")]),t._v(" "),a("p",[t._v("S0C：第一个幸存区的大小，单位KB")]),t._v(" "),a("p",[t._v("S1C：第二个幸存区的大小")]),t._v(" "),a("p",[t._v("S0U：第一个幸存区的使用大小")]),t._v(" "),a("p",[t._v("S1U：第二个幸存区的使用大小")]),t._v(" "),a("p",[t._v("EC：伊甸园区的大小")]),t._v(" "),a("p",[t._v("EU：伊甸园区的使用大小")]),t._v(" "),a("p",[t._v("OC：老年代大小")]),t._v(" "),a("p",[t._v("OU：老年代使用大小")]),t._v(" "),a("p",[t._v("MC：方法区大小（元空间）")]),t._v(" "),a("p",[t._v("MU：方法区使用大小")]),t._v(" "),a("p",[t._v("CCSC：压缩类空间大小")]),t._v(" "),a("p",[t._v("CCSU：压缩类空间使用大小")]),t._v(" "),a("p",[t._v("YGC：年轻代垃圾回收次数")]),t._v(" "),a("p",[t._v("YGCT：年轻代垃圾回收消耗时间，单位s")]),t._v(" "),a("p",[t._v("FGC：老年代垃圾回收次数")]),t._v(" "),a("p",[t._v("FGCT：老年代垃圾回收消耗时间，单位s")]),t._v(" "),a("p",[t._v("GCT：垃圾回收消耗总时间，单位s")]),t._v(" "),a("p",[a("strong",[t._v("优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。")])]),t._v(" "),a("p",[a("strong",[t._v("内存泄漏的一种情况")]),t._v("：一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就 简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老 年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存 资源，时间长了除了导致full gc，还有可能导致OOM。")])])}),[],!1,null,null,null);s.default=v.exports}}]);